<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Javascript语法]]></title>
      <url>%2F2016%2F01%2F24%2FJavascript_grammar%2F</url>
      <content type="text"><![CDATA[##区分大小写ECMAScript中的一切（变量、函数名和操作符）都区分大小写，变量名test和变量名Test分别表示两个不同的变量。 ##标识符所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。标识符可以是按照下列各式规则组合起来的一或多个字符： 第一个字符必须是一个字母、下划线或一个美元符号； 其他字符可以是字母、下划线、美元符号或数字 关键字或保留字不能用作标识符 ##注释 单行注释 // 多行注释 /**/ ##变量变量命名规则： 可以是数字、字母、下划线或美元符号组成 不允许数字开头 不允许使用关键字 不允许使用保留字 （保留字是指目前还不是关键字，但在未来可能会成为关键字） 推荐使用驼峰式命名法，即从第二个单词开始，每个单词的首字母大写定义变量时要使用var操作符，比如：var message;这行代码定义了一个名为message的变量，该变量可以用来保存任何值（未经过初始化的变量，会保存一个特殊的值——undefined） 注意：使用var操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁。例如：12345function test()&#123; var message = &quot;hi&quot;;//局部变量&#125;test();alert(message);//错误！ 下面这样省略var操作符，就创建了一个全局变量：12345function test()&#123; message = &quot;hi&quot;;//全局变量&#125;test();alert(message);//&quot;hi&quot; 可以使用一条语句定义多个变量，只要像下面这样把每个变量（初始化或不初始化均可）用逗号分隔开即可：123var message = &quot;hi&quot;, found = false, age = 29; ##数据类型5种基本（简单）数据类型： – Undefined、Null、Boolean、Number、String String: 字符串，由成对的单引号或者双引号包起来的0个或多个字符组成的串 Number: 数字 -Infinity ~ Infinity 之间 分为小数（浮点数）和整数 Infinity 正无穷大 js中最大的值 -Infinity 负无穷大 js中最小的值 Boolean:布尔值（ true、false） 一般用布尔值判断真假，进行流程控制 Undefined： 声明一个对象，并未给其赋值，那么这个变量内存储的就是undefined Null : 值只有一个null，是一个对象 1种复杂数据类型： – Object 复合类型是由简单和复合的数据类型组成的 对象，是用一对{}包起来的，由0对或多对 键名和键值组成的对组成，每对键值对之间用&quot;,&quot;隔开,最后不用加&quot;,&quot; ###typeof 操作符typeof （是一个操作符而不是函数）用来检测数据类型，返回值是一个字符串（首字母都是小写的）比如”number”、”function”，对一个值使用typeof操作符可能返回下列某个字符串： “undefined”——如果这个值未定义； “boolean”——如果这个值是布尔值； “string”——如果这个值是字符串； “number”——如果这个值是数值； “object”——如果这个值是对象或null; “function”——如果这个值是函数。 注意：typeof null会返回”object”,因为null被认为是一个空的对象引用。 Undefined类型在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。包含undefined值的变量与尚未定义的变量是不一样的，看下面的例子：123var message;alert( message ); //undefined，message声明了但是没有赋值alert( age ); //报错，因为age未声明 然后，令人困惑的是：对未初始化的变量执行typeof操作符会返回undefined值，而对未声明的变量执行typeof操作符同样也会返回undefined值，看下面的例子：12alert(typeof message) //undefinedalert(typeof age) //undefined 未初始化的变量会自动被赋予undefined值 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。 实际上undefined值是派生自null值的，因此：alert( null == undefined ); // true ###数据类型转换把一种数据类型转换成另一种数据类型。 1、转数字: Number(数据) 把数据转换成数字，返回这个数字（但是不会改变括号中数据的类型） parseInt(数据 ) 把数据转变成整数，舍去小数位取整数 parseFloat(数据 ) 把数据转变成小数（浮点数） parseInt(数据 )和 parseFloat(数据 ) 这两个方法会从左往右开始，除去空格，找到第一位非0数字，开始进行转换，直到转换到不是数字的那位为止，或者，转换出合适的值为止 注意： 如果数据的内容是纯粹的数字，才可以转成数字 否则会转换出NaN NaN： not a number 不是数字 数据类型是number NaN和任何东西都不相等，包括它自己 alert( NaN==NaN ) =&gt; false isNaN(数据): 判断数据是不是NaN 会把数据先使用Number进行转换，转换完之后再判断是不是NaN 如果数据是NaN那么返回true 如果数据不是NaN返回false 2、转字符串： String(数据) 把数据转换成字符串，返回这个字符串（但是不会改变括号中数据的类型） &quot;&quot;+ 3、转布尔值： Boolean(数据) 把数据转换成布尔值，返回这个布尔值（不会改变括号内数据的类型） !! 注意： 空字符串转换成false，其他非空的字符串都转换成true undefined,null,空字符串,0,NaN会转换成false,其余转变结果是true 隐式类型转换：不调用方法使数据的类型发生改变 +、-、*、/ 都可以进行隐试类型转换，在转换过程中没有调用方法，直接把两边都转换成数字 ，然后进行运算 + 还有字符串拼接功能，当两边有一个是字符串时就会把数字变成字符串，然后进行字符串拼接 ! 把数据转换成布尔值（比如： alert(!!2) //true） 显式类型转换： 使用一些方法 使数据的类型发生改变。 比如：Number()，parsent()，parseFloat()，String()，Boolean() 。。。 ##操作符 算数运算符： + 加、- 减、* 乘、/ 除、% 取模（求余数）、++、-- + 除了有算数运算的功能还有字符串拼接的功能 只有当两边都是 数字的时候才会进行算数运算 只要有一边是字符串，那么就会把不是字符串的那边转换成字符串，然后进行拼接 ++ 和-- 可以写在运算数的前面也可以写在运算数的后面 比如： a++，写在运算数的后面，先使用a再进行++ ++a，写在运算数的前面，先++再使用a a--，写在运算数的后面，先使用a再进行-- --a，写在运算数的前面，先--再使用a 赋值运算符： =、+=、-=、*=、/=、%= a+=b 相当于 a = a + b（a放在前面） a = a + b可以简写成 a += b 但是 a = b + a不可以简写成 a += b -=、*=、/=、%=的特性和+=一样 关系运算符： &lt;、&gt;、&lt;=、&gt;=、==、!=、===、!== 注意：返回值都是一个布尔值 &lt;小于 如果左边的值小于右边那么返回true 否则返回false &gt;大于 如果左边的值大于右边那么返回true 否则返回false &lt;=小于等于 如果左边的值小于或者等于右边那么返回true 否则返回false &gt;=大于等于 如果左边的值大于或者等于右边那么返回true 否则返回false ==等于 如果左边的值等于右边那么返回true； 注意：只判断外在的值是否一样，不会判断左右两边值的数据类型 比如： 1 == &quot;1&quot; 返回 true var a=1,b=&quot;1&quot;; console.log(a==b) =&gt;true; != 不等于 如果左边的值不等于右边那么返回true； 注意：不会判断左右两边值的数据类型 比如： 1 != &quot;1&quot; 返回false ==和！= 先转换再比较 === 全等 如果左右两边的值相等，并且数据类型也相同，则返回true 如果值不相等，或者数据类型不相同，则返回false !== 全不等 如果左右两边的值不相等，或者数据类型不相同，则返回true 如果值相等，并且数据类型也相同，则返回false ===和！==仅比较不转换 比较两个操作符时的规则： 1. null和undefined是相等的 2. 要比较相等性之前，不能将null和undefined转换成其他任何值 3. NaN不等于任何值，包括它本身 4. 如果两个操作数都是对象，则比较它们是不是同一个对象 true==1 // true true==2 // false undefined==0 // false null==0 // false &quot;5&quot;==5 // true false == 0 //true null==undefined //true NaN != NaN //true 逻辑运算符： &amp;&amp; 与、|| 或、! 否 、三元运算符 &amp;&amp;与（并且） 如果左边为真，则返回右边， 如果左边为假，则返回左边。 ||或（或者） 如果左边为真，则返回左边， 如果左边为假，则返回右边。 !否 把后面的运算数转成布尔值然后取反 三元运算符 判断条件?语句1:语句2 如果判断条件成立，执行语句1， 判断条件不成立，执行语句2 ##语句 ###if语句：只有if时：12345 if(判断条件))&#123; 执行语句 &#125;``` if...else... if(判断条件)){ 判断条件成立，执行这里的语句 }else{ 判断条件不成立，执行这里的语句 } 12 if和else嵌套 if(判断条件)){ if(判断条件)){ 执行语句 } }else if(判断条件)){ 执行语句 }else if(判断条件)){ 执行语句 }else if(判断条件)){ 执行语句 } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220###do-while语句： do&#123; 执行语句 &#125; while ( 判断条件 ) 比如： var i = 0; do&#123; i+=2; &#125; while ( i &lt; 10 ); 在这个例子中，只要变量i的值小于10，循环就会一直继续下去###while 语句 ： while( 判断条件 )&#123; 循环体 &#125; 比如： var i=0 while( i&lt;3 )&#123; alert(i); i++; &#125; ###for语句：根据一定的条件，重复执行一行或多行代码语法： for(1.初始化；2.判断条件；4.变量改变)&#123; 3.条件成立的时候执行的一行或者多行代码 &#125;执行顺序： 1.初始化 2.判断条件 3.条件成立的时候执行的一行或者多行代码 4.变量改变 2.判断条件 3.条件成立的时候执行的一行或者多行代码 4.变量改变 。。。 如果条件不成立，跳出循环###for in语句用于对数组或者对象的属性进行循环操作循环中的代码每执行一次，就会对数组的元素或者对象的属性进行一次操作 语法： for (变量 in 对象) &#123; 在此执行代码 &#125;###switch语句： switch (变量)&#123; case 值1: 变量值为值1的时候执行的代码 break; case 值2: 变量值为值2的时候执行的代码 break; case 值3: 变量值为值3的时候执行的代码 break; case 值4: 变量值为值4的时候执行的代码 break; default: 当变量值不为值1、值2、值3、值4执行的代码 break; &#125; switch的穿透性 如果case语句的后面不加break，那么会执行满足条件的语句后面所有的语句 if(i==25)&#123; alert(&quot;25&quot;); &#125;else if(i==35)&#123; alert(&quot;35&quot;); &#125;else if(i==45)&#123; alert(&quot;45&quot;); &#125;else&#123; alert(&quot;other&quot;); &#125; //与此等价的switch语句如下： switch(i)&#123; case 25: alert(&quot;25&quot;); break; case 35: alert(&quot;25&quot;); break; case 45: alert(&quot;25&quot;); break; default: alert(&quot;other&quot;); &#125;###break语句和continue语句：**break ：** 跳出语句（跳出break所在的for循环）作用：可以用来控制for循环的执行**continue ：** 跳出本次循环，本次for循环后面的代码都不会执行了，继续执行下一次**return：** 中断整个函数对比：continue 语句（带有或不带标签引用）只能用在循环中。break 语句（不带标签引用），只能用在循环或 switch 中。return 只能用在函数中##函数函数是复用的代码块申明函数： 下面用[]包起来的部分代表可以写也可以不写 function [函数名]([参数])&#123; 要复用的代码 &#125; 有函数名的叫有名函数，没有函数名的叫匿名函数 注意： 匿名函数不能直接申明，会报错函数类型： 1、函数声明 function [函数名]([参数])&#123; &#125; 调用方法： 函数名([参数]) 2、函数表达式 var fn1 = function()&#123; &#125; 调用方法： fn1([参数]) 函数声明和函数表达式区别：&gt; * 函数声明可以先调用再申明， 函数表达式不可以先调用再申明，会报错&gt; * 声明方式不同: function name() &#123; &#125; 匿名函数：（匿名就是不写名字的函数，暂时匿名只能写在事件上，否则会报错） function ()&#123; &#125;&gt; * 调用方式不同： 1. 正常调用 name(); 2. 事件调用 onclick = name;参数：功能：我们希望函数的功能更加强大，富有拓展性如果没有参数，只要需求稍微改变，那么我们的函数就要重新写了参数就是给函数使用的变量使用参数：需要在函数声明的时候把参数写进去比如：function fn( 参数名 )&#123; &#125;###参数的划分:**形参：**（形参是在函数内部使用的） 形式上的参数（函数定义的时候写的） 写在函数定义时的小括号里面 多个参数以逗号分开 注意：形参与实参是一 一对应的关系，只能在函数的内部使用**实参：**实际传入的参数（在函数调用的时候写的 ） 写在函数调用的时候的小括号里面 如果写了形参，却没有对应实参，那么在函数调用的时候对应形参的位置上的值是undefined 一般把使用频率大的参数放到前面，方便进行 一 一 对应**不定参：** arguments 当参数的个数不确定的时候，使用不定参 使用： 只能在函数内部使用 类数组，保存实际传入的参数的集合 拥有length属性 可用下标获取实际参数对应的值没有传递值的命名参数将自动被赋予undefined值。这就跟定义了变量但又没有初始化一样**return 返回值：** 只能在函数中使用函数会在执行完return语句之后停止并立即退出，因为，return语句之后的任何代码都永远不会执行。 function sum(num1,num2){ return num1+num2; alert(“hellow”); //此句永远不会执行}```作用： 1.return后面跟的值为函数执行后的返回值 2.return后面不跟值，可以停止函数继续执行，函数停止执行后将返回undefined值，这种用法一般在需要提前停止函数执行而又不需要返回值的情况下。 函数执行完成后都有返回值 如果我们希望使用函数的执行结果做另一件事情，那么我们需要使用函数返回值 如果不使用return的话，函数默认返回值为undefined 如果return后面没有值的话，函数返回值也为undefined 使用return 后面跟值的话，函数返回值就是return后面的值 注意：当用到return语句时，要注意function（）和function的区别，前者返回的是函数执行完的值， 后者直接返回的是函数【这个通常用于把函数当做参数传递另一个函数中去】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于Hexo和Github搭建博客]]></title>
      <url>%2F2016%2F01%2F24%2Fhexo_github%2F</url>
      <content type="text"><![CDATA[Node Node.js — 类似一个操作系统 一个JS的运行环境 主要用于开发Web应用程序（回想登陆的例子） 很多的前端开发工具都是基于node这个平台 所用的工具就相当于一些软件 NVM （可选的） Node Version Manager(Node的版本管理工具) 因为node的版本比较多，很多时候我们可能依赖多个版本，并要求自由切换 使用 nvm use [对应的版本号] [平台架构（如果是32系统需要写32,64位不用管）] nvm install [arch] 安装 nvm uninstall 卸载 nvm list 查看已经安装版本 官网 https://github.com/coreybutler/nvm-windows NPM node package manager(node的包管理工具) npm管理包非常方便，我们只需要记住使用哪个包就可以了 使用 npm install xxx 安装一个包到项目本地，必须要联网 安装完成过后项目根目录下会多一个node_modules文件夹，所有的下载下来的包全部在里面 由于需要记录项目依赖哪些东西，所以需要一个配置文件“package.json”，可以通过npm init命令生成 以后安装包的时候将其–save –save就是将我们安装的包名字和包版本记录到配置文件中的dependencies节点中 –save-dev 项目依赖分两种，一个就是普通的项目依赖比如bootstrap，还用一种只是开发阶段需要用的，这种属于开发依赖比如gulp，开发依赖最终记录在devDependencies节点里面 npm uninstall xxx –save npm install xxx -g(全局安装包) 如果你安装的是一个工具，工具要在每一个地方都能用，这种情况下一般全局安装。 Bower Web sites are made of lots of things — frameworks, libraries, assets, and utilities. Bower manages all these things for you. Bower就是用来管理项目中所有的依赖，主要用于Web页面开发时使用的包管理，比如jquery，bootstrap 重复的轮子太多，抓住轮子与轮子之间的共性 Gulp FIS3 http://www.ydcss.com/archives/94 msi - microsoft installer 微软安装器 GIT什么是GIT 是一个源代码管理工具 在一个项目中，凡是由开发人员编写的都算是源代码 源代码有必要管理起来？ 让源代码可以被追溯，主要记录每次变更了什么，谁主导这次变化 人为的维护比较麻烦， GIT是Linux之父当年为了维护管理Linux的源代码写的一个工具 Git 之前 很多使用 svn vss tfs hs …… https://guides.github.com/ 安装GIT git命令行工具 基于git命令行的一个客户端软件（提供一个界面去管理源代码） GIT命令操作 初始化一个本地GIT仓储 12cd 当前项目目录git init // 初始化一个本地的仓库 就是在本地文件夹中添加了一个.git的文件夹用于记录所有的项目变更信息 查看本地仓储的变更状态 git status用于查看本地仓储的状态第一次查看，显示的是一坨没有被跟踪的文件 git status -s // -s 是输出简要的变更日志 添加本地暂存（托管）文件 git add可以将一个没有被跟踪的文件添加到跟踪列表 类似于node_modules这种性质的文件是不应该被跟踪 添加本地GIT忽略清单文件 在代码库文件夹的根目录添加一个.gitignore文件此文件用于说明忽略的文件有哪些 提交被托管的文件变化到本地仓储 git commit将本地的变化提交的本地的仓库文件夹归档一般在有了一个小单元的整体变化后再提交 对比差异 git diff可以用于对比当前状态和版本库中状态的变化 提交日志 git log可以查看提交日志 回归到指定版本 git reset –hard 为仓储添加远端（服务器端）地址 将本地仓储的提交记录推送到远端的master分支 拉取远端master分支的更新记录到本地 回归到指定版本 GITHUB基本使用 https://github.com/ GITHUB是一个GIT服务的提供商， 提出社交化编程 http://zoomzhao.github.io/code-guide/https://github.com/jobbole/awesome-javascript-cnhttps://github.com/jobbole/awesome-css-cn GIT分支 Angular入门简介 知识储备 什么是Angular 快速构建Web应用程序 单页面应用程序 Angular的特性 为什么要用Angular 让Web应用程序开发更简单，更快捷 带领前端进入MV*的时代 开始使用 引用Angular 下载 bower npm 基本使用]]></content>
    </entry>

    
  
  
</search>

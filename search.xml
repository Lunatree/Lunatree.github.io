<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Array的对象方法]]></title>
      <url>%2F2017%2F02%2F11%2FAn%20array%20of%20object%20method%2F</url>
      <content type="text"><![CDATA[Array.from()作用： 可以将一个类数组对象转换成真正的数组 用法： Array.from( obj,[ callback ],[ thisArg ] ) 参数： obj 类数组 callback 对转成数组每一项进行处理 thisArg 改变回调函数中this的指向 返回值： 新数组 Array.isArray()作用： 判断一个值是否是数组类型， 是返回true，否则放回false 用法： Boolean Array.isArray(arg) 参数： 任意类型的值 返回值： 布尔值 arr.filter()作用 使用指定函数测试所有元素， 并创建一个包含所有通过测试的元素的新数组。 语法 Array arr.filter(callback,[thisArg]) 参数 callback(value,index,arr) value为循环的值 index为下标 arr为被操作的数组 返回值 新数组 描述 filter 为数组中的每个元素调用一次 callback 函数， callback返回值为true，则把值放入新数组中，否则不放入。 arr.every()作用 测试数组的所有元素是否都通过了指定函数的测试 语法 Boolean arr.every(callback,[thisArg]) 参数 callback(value,index,arr) value为循环的值 index为下标 arr为被操作的数组 返回值 布尔值 描述 every为数组中的每个元素调用一次 callback 函数， 如果数组的元素都通过callback函数的测试，则返回true， 否则只要有一个没有检测通过，则返回false arr.map()作用： 返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。 用法： Array Array.map([callback],[thisArg]) 参数： callback 对转成数组每一项进行处理 返回值 新数组 arr.find()作用： 返回数组中满足测试条件的第一个值，如果没有满足条件的，则返回undefind 用法： Any Array.find([callback],[thisArg]) 参数： callback 返回值： 任意类型的值 arr.findIndex()作用： 返回数组中满足测试条件的第一个值的下标，如果没有满足条件的，则返回-1 用法： Number Array.findIndex([callback],[thisArg]) 参数： callback 返回值： 任意类型的值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[闭包]]></title>
      <url>%2F2017%2F02%2F10%2Fbibao%2F</url>
      <content type="text"><![CDATA[一、变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。变量的作用域无非就是两种：全局变量和局部变量。Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。12345 var n=999; function f1()&#123; alert(n); &#125; f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。1234 function f1()&#123; var n=999; &#125; alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！12345 function f1()&#123; n=999; &#125; f1(); alert(n); // 999 二、如何从外部读取局部变量？出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。123456 function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125; &#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！123456789 function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 三、闭包的概念闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 四、闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。怎么来理解这句话呢？请看下面的代码。123456789101112 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 五、使用闭包的注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当做对象（object）使用，把闭包当做它的公用方法，把内部变量当作它的私有属性，这时一定要小心，不要随便改变父函数内部变量的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[null与undefined的区别]]></title>
      <url>%2F2017%2F02%2F10%2Fnull_undefined_difference%2F</url>
      <content type="text"><![CDATA[null表示”没有对象”，即该处不应该有值。典型用法是：1、作为函数的参数，表示该函数的参数不是对象2、作为对象原型链的终点undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是： 1、变量被声明了，但是没有被赋值，就等于undefined2 、调用函数时，应该提供的参数没有提供，该参数等于undefined3、对象没有赋值的属性，该属性的值为undefined4、函数没有返回值时，默认返回undefined]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字符串方法]]></title>
      <url>%2F2017%2F02%2F09%2FString_method%2F</url>
      <content type="text"><![CDATA[charAt作用 方法返回字符串中指定位置的字符 语法 string string.charAt(index) 参数 index 0 到 字符串长度-1 的一个整数 返回值 返回字符串 注意：如果index小于0或者大于等于字符串长度，返回空字符串 charCodeAt作用 返回指定索引处字符的 Unicode 数值 语法 number string.charCodeAt(index) 参数 index 一个大于等于 0，小于字符串长度的整数。如果不是一个数值，则默认为 0。 返回值 返回指定索引处字符的 Unicode 数值 indexOf作用 返回指定值在调用该方法的字符串中首次出现的位置 语法 number string.indexOf(searchValue [, fromIndex]) 参数 searchValue 一个字符串表示被查找的值 fromIndex 开始查找的位置，默认值为0 返回值 返回数字 如果存在返回位置，如果不存在返回-1 PS: var str=”hello world”;console.log( str.indexOf(“e”) ) =&gt; 1console.log( str.indexOf(“e”,6) ) =&gt; -1,不存在console.log( str.indexOf(“e”,-1) ) =&gt; -1 lastIndexOf作用 返回指定值在调用该方法的字符串中最后出现的位置 语法 number string.lastIndexOf(searchValue [, fromIndex]) 参数 searchValue 一个字符串表示被查找的值 fromIndex 开始查找的位置，默认值为str.length-1 返回值 返回数字 如果存在返回位置，如果不存在返回-1 PS: var str=”hello world”;console.log( str.lastIndexOf(“l”) ) =&gt; 9,默认从最后一位开始往前查找到的第一次出现的位置console.log( str.lastIndexOf(“l”,6) ) =&gt; 3,从下标6的位置开始往前查找的第一次出现的位置console.log( str.latIndexOf(“l”,-1) ) =&gt; -1 不存在 slice作用 方法提取字符串中的一部分，并返回这个新的字符串（包含起始位置，不包含结束位置） 语法 string string.slice(beginSlice[, endSlice]) 参数 beginSlice 起始位置 endSlice 结束位置，默认为最后一个字符的位置+1 返回值 返回截取后的字符串 不会根据参数大小 交换参数位置 如果参数中有负值，则处理成从末尾开始数（倒数） PS: var str=”hello world”;console.log( str.slice() ) =&gt; hello worldconsole.log( str.slice(0) ) =&gt; hello worldconsole.log( str.slice(2,6) ) =&gt; llo,包含起始位置，不包含结束位置console.log( str.slice(-3) ) =&gt; rld ,从倒数第3位开始向末尾截取console.log( str.slice(-3，-1) ) =&gt; rl ,从倒数第3位开始向倒第1位截取，不包含倒数第1位 split作用 通过一个指定的字符串把原字符串分割成一个数组 语法 array string.split([separator] [, limit]) 参数 separator 分割符 limit 指定最多分割的数量，默认为全部 返回值 返回一个数组 当没有分割符的时候，整个字符串将作为一个整体保存到数组中 PS: var str=”hello world”;console.log( str.split() ) =&gt; [“hello world”]console.log( str.split(“”) ) =&gt; [“h”, “e”, “l”, “l”, “o”, “ “, “w”, “o”, “r”, “l”, “d”]console.log( str.split(“ “) ) =&gt; [“hello”, “world”]console.log( str.split(“|”) ) =&gt; [“hello world”],分割字符串不存在，就把整个字符串作为一个整体保存到数组中 substring作用 截取指定位置之间的字符串 语法 string string.substring(indexStart [, indexEnd]) 参数 indexStart 截取的起始位置 indexEnd 截取的结束位置，默认为最后一个字符的位置+1 返回值 返回截取后的字符串 会根据起始位置和结束位置的大小先进行参数位置的变换，再进行截取 会把负值转换成0 PS: var str=”hello world”;console.log( str.subsring() ) =&gt; hello worldconsole.log( str.subsring(0) ) =&gt; hello worldconsole.log( str.subsring(2,6) ) =&gt; llo,包含起始位置，不包含结束位置console.log( str.subsring(-3) ) =&gt; hello world ,会先把负值转换成0console.log( str.subsring(-3，-1) ) =&gt; 空 substr作用 截取指定起始位置和长度的子字符串 语法 string string.substr(start [, length]) 参数 start 截取的起始位置 length 截取的字符串长度，默认为字符长度 返回值 返回截取后的字符串 PS: var str=”hello world”;console.log( str.substr() ) =&gt; hello worldconsole.log( str.substr(0) ) =&gt; hello worldconsole.log( str.substr(0,2) ) =&gt; heconsole.log( str.substr(-3) ) =&gt; rld ,从倒数第三位开始截取，默认为倒数第二位后面的字符长度console.log( str.substr(-3，1) ) =&gt; r ,从倒数第三位开始截取长度为1的字符串console.log( str.substr(-3，4) ) =&gt; rld ,从倒数第三位开始截取长度为4的字符串，超出了默认长度，直接截取默认长度 toLowerCase作用 把字符串全部转成小写 语法 string string.toLowerCase() 返回值 返回转成小写的字符串 toUpperCase作用 把字符串全部转成大写 语法 string string.toUpperCase() 返回值 返回转成大写的字符串 trim作用 去掉字符串首尾的全部空格 语法 string string.trim() 返回值 返回去除首尾全部空格后的字符串 trimLeft() 清除字符串左边的空格 trimRight() 清除字符串右边的空格 JSON JSON(JavaScript Object Notation)是一种轻量级的数据交换格式，一种类似JS中的对象格式的字符串 JSON规则 数据以{}或者[]作为起始和结束 &apos;{}&apos; &apos;[]&apos; 每个数据使用键值对形式 key : value key必须使用&quot;&quot;包含 多个值之间使用逗号分隔 JSON操作方法 object JSON.parse(JSONString) 把JSONString转换成JS中对象类型 var json1 = &apos;{&quot;name&quot;:&quot;tong&quot;}&apos;; var obj = JSON.parse( json1 );//把JSON格式字符串转换成JS中对象类型 console.log( obj );//结果是:&quot;[object object]&quot; var json1 = &apos;[1,2,4,5]&apos;; var obj = JSON.parse( json1 );//把JSON格式字符串转换成JS中对象类型 console.log( obj );//结果是&quot;1,2,4,5&quot; string JSON.stringify(object) 把object转成JSON格式的字符串 var obj = { &quot;name&quot;:&quot;tong&quot; } console.log(JSON.stringify(obj) );//结果：&quot;{&quot;name&quot;:&quot;tong&quot;}&quot;，把object转成JSON格式的字符串]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数组方法]]></title>
      <url>%2F2017%2F02%2F08%2FArray_method%2F</url>
      <content type="text"><![CDATA[arr.push() 添加一个元素到数组的末尾 ，返回新数组的长度length 会改变原数组 arr.pop() 删除数组最后一个元素（每次只能删除一个元素 ），返回被删除的那一个元素 会改变原数组 arr.unshift() 添加一个或多个元素到数组的头部，返回新数组的长度length 会改变原数组 arr.shift () 删除数组的第一个元素（每次只能删除一个元素 ） ，返回被删除的那一个元素 会改变原数组 arr.forEach () 让数组的每一项都执行一次给定的函数 123arr.forEach(function( a,b,c )&#123;console.log( a,b,c ) //a:当前项的值；b:当前项的下标；c:数组本身（用的比较少，一般不加c参数）&#125;) arr.sort () 对数组的元素进行排序，返回值是排序后的数组 var arr = [3,1,2,4,7,0]; arr.sort();=&gt;[0,1,2,3,4,7] arr.sort(function(a,b){ // return -1//返回值是小于等于0的数不交换顺序 // return 1//返回值是大于0的数交换顺序 // return a - b;//从小到大 // return b - a;//从大到小 if( a&gt;b ){ return 1 }else{ return -1 } }) arr.sort(function(){ return Math.random()-0.5;//打乱数组元素顺序 }) arr.concat() 将传入的数组或非数组值与原数组合并，组成一个新的数组并返回，返回值是合并后的数组，不会改变原数组的内容arr.reverse() 颠倒数组中元素的位置，返回值是颠倒顺序后的数组，会改变原数组的元素顺序arr.join()将数组中所有元素连接成一个字符串，返回值是一个字符串，不会改变原数组的内容 例:1234var arr=[1,2,3]arr.join() =&gt; 1,2,3 不传参数，默认用“，”进行拼接arr.join(&quot;&quot;) =&gt; 123 此处传入了参数，是&quot;&quot;arr.join(&quot;+&quot;) =&gt; 1+2+3 此处传入了参数，是&quot;+&quot; arr.slice() 截取数组中的一部分，并返回这个新的数组 （包含起始位置，不包含结束位置）不会改变原数组内容 例:1234567var arr=[1,2,3,4,5,6];console.log( arr.slice() ) =&gt; [1,2,3,4,5,6]console.log( arr.slice(0) ) =&gt; [1,2,3,4,5,6]console.log( arr.slice(2) ) =&gt; [3,4,5,6]console.log( arr.slice(0,3) ) =&gt; [1,2,3] 不包含结束位置console.log( arr.slice(-3) ) =&gt; [4,5,6] 截取倒数第三位开始到末尾的数组console.log( arr.slice(-3，-1) ) =&gt; [4,5] 截取倒数第三位和倒数第一位之间的数组 arr.splice() 用新元素替换旧元素，以此修改数组的内容，返回值是由被删除的元素组成的一个数组，修改了原数组的内容 arr.splice(起始位置，删除长度，”添加的内容”) 添加的内容加在了被删除的位置 例:1234var arr=[1,2,3,4,5,6]arr.splice （1,2） =&gt; [2,3] //删除arr.splice （1,2,&quot;f&quot;） =&gt; console.log(arr) =&gt; [1,f,4,5,6] //先删除后添加arr.splice （2,0,&quot;f&quot;） =&gt; console.log(arr) =&gt; [1,2,f,3,4,5,6] //添加]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript语法]]></title>
      <url>%2F2017%2F02%2F08%2FJavascript_grammar%2F</url>
      <content type="text"><![CDATA[区分大小写ECMAScript中的一切（变量、函数名和操作符）都区分大小写，变量名test和变量名Test分别表示两个不同的变量。 标识符所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。标识符可以是按照下列各式规则组合起来的一或多个字符： 第一个字符必须是一个字母、下划线或一个美元符号； 其他字符可以是字母、下划线、美元符号或数字 关键字或保留字不能用作标识符 注释 单行注释 // 多行注释 /**/ 变量变量命名规则： 可以是数字、字母、下划线或美元符号组成 不允许数字开头 不允许使用关键字 不允许使用保留字 （保留字是指目前还不是关键字，但在未来可能会成为关键字） 推荐使用驼峰式命名法，即从第二个单词开始，每个单词的首字母大写定义变量时要使用var操作符，比如：var message;这行代码定义了一个名为message的变量，该变量可以用来保存任何值（未经过初始化的变量，会保存一个特殊的值——undefined） 注意：使用var操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁。例如：12345function test()&#123; var message = &quot;hi&quot;;//局部变量&#125;test();alert(message);//错误！ 下面这样省略var操作符，就创建了一个全局变量：12345function test()&#123; message = &quot;hi&quot;;//全局变量&#125;test();alert(message);//&quot;hi&quot; 可以使用一条语句定义多个变量，只要像下面这样把每个变量（初始化或不初始化均可）用逗号分隔开即可：123var message = &quot;hi&quot;, found = false, age = 29; 数据类型5种基本（简单）数据类型： – Undefined、Null、Boolean、Number、String String: 字符串，由成对的单引号或者双引号包起来的0个或多个字符组成的串 Number: 数字 -Infinity ~ Infinity 之间 分为小数（浮点数）和整数 Infinity 正无穷大 js中最大的值 -Infinity 负无穷大 js中最小的值 Boolean:布尔值（ true、false） 一般用布尔值判断真假，进行流程控制 Undefined： 声明一个对象，并未给其赋值，那么这个变量内存储的就是undefined Null : 值只有一个null，是一个对象 1种复杂数据类型： – Object 复合类型是由简单和复合的数据类型组成的 对象，是用一对{}包起来的，由0对或多对 键名和键值组成的对组成，每对键值对之间用&quot;,&quot;隔开,最后不用加&quot;,&quot; typeof 操作符typeof （是一个操作符而不是函数）用来检测数据类型，返回值是一个字符串（首字母都是小写的）比如”number”、”function”，对一个值使用typeof操作符可能返回下列某个字符串： “undefined”——如果这个值未定义； “boolean”——如果这个值是布尔值； “string”——如果这个值是字符串； “number”——如果这个值是数值； “object”——如果这个值是对象或null; “function”——如果这个值是函数。 注意：typeof null会返回”object”,因为null被认为是一个空的对象引用。 Undefined类型在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。包含undefined值的变量与尚未定义的变量是不一样的，看下面的例子：123var message;alert( message ); //undefined，message声明了但是没有赋值alert( age ); //报错，因为age未声明 然后，令人困惑的是：对未初始化的变量执行typeof操作符会返回undefined值，而对未声明的变量执行typeof操作符同样也会返回undefined值，看下面的例子：12alert(typeof message) //undefinedalert(typeof age) //undefined 未初始化的变量会自动被赋予undefined值 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。 实际上undefined值是派生自null值的，因此：alert( null == undefined ); // true 数据类型转换把一种数据类型转换成另一种数据类型。 1、转数字: Number(数据) 把数据转换成数字，返回这个数字（但是不会改变括号中数据的类型） parseInt(数据 ) 把数据转变成整数，舍去小数位取整数 parseFloat(数据 ) 把数据转变成小数（浮点数） parseInt(数据 )和 parseFloat(数据 ) 这两个方法会从左往右开始，除去空格，找到第一位非0数字，开始进行转换，直到转换到不是数字的那位为止，或者，转换出合适的值为止 注意： 如果数据的内容是纯粹的数字，才可以转成数字 否则会转换出NaN NaN： not a number 不是数字 数据类型是number NaN和任何东西都不相等，包括它自己 alert( NaN==NaN ) =&gt; false isNaN(数据): 判断数据是不是NaN 会把数据先使用Number进行转换，转换完之后再判断是不是NaN 如果数据是NaN那么返回true 如果数据不是NaN返回false 2、转字符串： String(数据) 把数据转换成字符串，返回这个字符串（但是不会改变括号中数据的类型） &quot;&quot;+ 3、转布尔值： Boolean(数据) 把数据转换成布尔值，返回这个布尔值（不会改变括号内数据的类型） !! 注意： 空字符串转换成false，其他非空的字符串都转换成true undefined,null,空字符串,0,NaN会转换成false,其余转变结果是true 隐式类型转换：不调用方法使数据的类型发生改变 +、-、*、/ 都可以进行隐试类型转换，在转换过程中没有调用方法，直接把两边都转换成数字 ，然后进行运算 + 还有字符串拼接功能，当两边有一个是字符串时就会把数字变成字符串，然后进行字符串拼接 ! 把数据转换成布尔值（比如： alert(!!2) //true） 显式类型转换： 使用一些方法 使数据的类型发生改变。 比如：Number()，parsent()，parseFloat()，String()，Boolean() 。。。 操作符算数运算符： + 加、- 减、* 乘、/ 除、% 取模（求余数）、++、-- + 除了有算数运算的功能还有字符串拼接的功能 只有当两边都是 数字的时候才会进行算数运算 只要有一边是字符串，那么就会把不是字符串的那边转换成字符串，然后进行拼接 ++ 和-- 可以写在运算数的前面也可以写在运算数的后面 比如： a++，写在运算数的后面，先使用a再进行++ ++a，写在运算数的前面，先++再使用a a--，写在运算数的后面，先使用a再进行-- --a，写在运算数的前面，先--再使用a 赋值运算符： =、+=、-=、*=、/=、%= a+=b 相当于 a = a + b（a放在前面） a = a + b可以简写成 a += b 但是 a = b + a不可以简写成 a += b -=、*=、/=、%=的特性和+=一样 关系运算符： &lt;、&gt;、&lt;=、&gt;=、==、!=、===、!== 注意：返回值都是一个布尔值 &lt;小于 如果左边的值小于右边那么返回true 否则返回false &gt;大于 如果左边的值大于右边那么返回true 否则返回false &lt;=小于等于 如果左边的值小于或者等于右边那么返回true 否则返回false &gt;=大于等于 如果左边的值大于或者等于右边那么返回true 否则返回false ==等于 如果左边的值等于右边那么返回true； 注意：只判断外在的值是否一样，不会判断左右两边值的数据类型 比如： 1 == &quot;1&quot; 返回 true var a=1,b=&quot;1&quot;; console.log(a==b) =&gt;true; != 不等于 如果左边的值不等于右边那么返回true； 注意：不会判断左右两边值的数据类型 比如： 1 != &quot;1&quot; 返回false ==和！= 先转换再比较 === 全等 如果左右两边的值相等，并且数据类型也相同，则返回true 如果值不相等，或者数据类型不相同，则返回false !== 全不等 如果左右两边的值不相等，或者数据类型不相同，则返回true 如果值相等，并且数据类型也相同，则返回false ===和！==仅比较不转换 比较两个操作符时的规则： 1. null和undefined是相等的 2. 要比较相等性之前，不能将null和undefined转换成其他任何值 3. NaN不等于任何值，包括它本身 4. 如果两个操作数都是对象，则比较它们是不是同一个对象 true==1 // true true==2 // false undefined==0 // false null==0 // false &quot;5&quot;==5 // true false == 0 //true null==undefined //true NaN != NaN //true 逻辑运算符： &amp;&amp; 与、|| 或、! 否 、三元运算符 &amp;&amp;与（并且） 如果左边为真，则返回右边， 如果左边为假，则返回左边。 ||或（或者） 如果左边为真，则返回左边， 如果左边为假，则返回右边。 !否 把后面的运算数转成布尔值然后取反 三元运算符 判断条件?语句1:语句2 如果判断条件成立，执行语句1， 判断条件不成立，执行语句2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于Hexo和Github搭建博客]]></title>
      <url>%2F2016%2F01%2F24%2Fhexo_github%2F</url>
      <content type="text"><![CDATA[Node Node.js — 类似一个操作系统 一个JS的运行环境 主要用于开发Web应用程序（回想登陆的例子） 很多的前端开发工具都是基于node这个平台 所用的工具就相当于一些软件 NVM （可选的） Node Version Manager(Node的版本管理工具) 因为node的版本比较多，很多时候我们可能依赖多个版本，并要求自由切换 使用 nvm use [对应的版本号] [平台架构（如果是32系统需要写32,64位不用管）] nvm install [arch] 安装 nvm uninstall 卸载 nvm list 查看已经安装版本 官网 https://github.com/coreybutler/nvm-windows NPM node package manager(node的包管理工具) npm管理包非常方便，我们只需要记住使用哪个包就可以了 使用 npm install xxx 安装一个包到项目本地，必须要联网 安装完成过后项目根目录下会多一个node_modules文件夹，所有的下载下来的包全部在里面 由于需要记录项目依赖哪些东西，所以需要一个配置文件“package.json”，可以通过npm init命令生成 以后安装包的时候将其–save –save就是将我们安装的包名字和包版本记录到配置文件中的dependencies节点中 –save-dev 项目依赖分两种，一个就是普通的项目依赖比如bootstrap，还用一种只是开发阶段需要用的，这种属于开发依赖比如gulp，开发依赖最终记录在devDependencies节点里面 npm uninstall xxx –save npm install xxx -g(全局安装包) 如果你安装的是一个工具，工具要在每一个地方都能用，这种情况下一般全局安装。 Bower Web sites are made of lots of things — frameworks, libraries, assets, and utilities. Bower manages all these things for you. Bower就是用来管理项目中所有的依赖，主要用于Web页面开发时使用的包管理，比如jquery，bootstrap 重复的轮子太多，抓住轮子与轮子之间的共性 Gulp FIS3 http://www.ydcss.com/archives/94 msi - microsoft installer 微软安装器 GIT什么是GIT 是一个源代码管理工具 在一个项目中，凡是由开发人员编写的都算是源代码 源代码有必要管理起来？ 让源代码可以被追溯，主要记录每次变更了什么，谁主导这次变化 人为的维护比较麻烦， GIT是Linux之父当年为了维护管理Linux的源代码写的一个工具 Git 之前 很多使用 svn vss tfs hs …… https://guides.github.com/ 安装GIT git命令行工具 基于git命令行的一个客户端软件（提供一个界面去管理源代码） GIT命令操作 初始化一个本地GIT仓储 12cd 当前项目目录git init // 初始化一个本地的仓库 就是在本地文件夹中添加了一个.git的文件夹用于记录所有的项目变更信息 查看本地仓储的变更状态 git status用于查看本地仓储的状态第一次查看，显示的是一坨没有被跟踪的文件 git status -s // -s 是输出简要的变更日志 添加本地暂存（托管）文件 git add可以将一个没有被跟踪的文件添加到跟踪列表 类似于node_modules这种性质的文件是不应该被跟踪 添加本地GIT忽略清单文件 在代码库文件夹的根目录添加一个.gitignore文件此文件用于说明忽略的文件有哪些 提交被托管的文件变化到本地仓储 git commit将本地的变化提交的本地的仓库文件夹归档一般在有了一个小单元的整体变化后再提交 对比差异 git diff可以用于对比当前状态和版本库中状态的变化 提交日志 git log可以查看提交日志 回归到指定版本 git reset –hard 为仓储添加远端（服务器端）地址 将本地仓储的提交记录推送到远端的master分支 拉取远端master分支的更新记录到本地 回归到指定版本 GITHUB基本使用 https://github.com/ GITHUB是一个GIT服务的提供商， 提出社交化编程 http://zoomzhao.github.io/code-guide/https://github.com/jobbole/awesome-javascript-cnhttps://github.com/jobbole/awesome-css-cn GIT分支]]></content>
    </entry>

    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Javascript语法]]></title>
      <url>%2F2017%2F02%2F08%2FJavascript_grammar%2F</url>
      <content type="text"><![CDATA[区分大小写ECMAScript中的一切（变量、函数名和操作符）都区分大小写，变量名test和变量名Test分别表示两个不同的变量。 标识符所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。标识符可以是按照下列各式规则组合起来的一或多个字符： 第一个字符必须是一个字母、下划线或一个美元符号； 其他字符可以是字母、下划线、美元符号或数字 关键字或保留字不能用作标识符 注释 单行注释 // 多行注释 /**/ 变量变量命名规则： 可以是数字、字母、下划线或美元符号组成 不允许数字开头 不允许使用关键字 不允许使用保留字 （保留字是指目前还不是关键字，但在未来可能会成为关键字） 推荐使用驼峰式命名法，即从第二个单词开始，每个单词的首字母大写定义变量时要使用var操作符，比如：var message;这行代码定义了一个名为message的变量，该变量可以用来保存任何值（未经过初始化的变量，会保存一个特殊的值——undefined） 注意：使用var操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁。例如：12345function test()&#123; var message = &quot;hi&quot;;//局部变量&#125;test();alert(message);//错误！ 下面这样省略var操作符，就创建了一个全局变量：12345function test()&#123; message = &quot;hi&quot;;//全局变量&#125;test();alert(message);//&quot;hi&quot; 可以使用一条语句定义多个变量，只要像下面这样把每个变量（初始化或不初始化均可）用逗号分隔开即可：123var message = &quot;hi&quot;, found = false, age = 29; 数据类型5种基本（简单）数据类型： – Undefined、Null、Boolean、Number、String String: 字符串，由成对的单引号或者双引号包起来的0个或多个字符组成的串 Number: 数字 -Infinity ~ Infinity 之间 分为小数（浮点数）和整数 Infinity 正无穷大 js中最大的值 -Infinity 负无穷大 js中最小的值 Boolean:布尔值（ true、false） 一般用布尔值判断真假，进行流程控制 Undefined： 声明一个对象，并未给其赋值，那么这个变量内存储的就是undefined Null : 值只有一个null，是一个对象 1种复杂数据类型： – Object 复合类型是由简单和复合的数据类型组成的 对象，是用一对{}包起来的，由0对或多对 键名和键值组成的对组成，每对键值对之间用&quot;,&quot;隔开,最后不用加&quot;,&quot; typeof 操作符typeof （是一个操作符而不是函数）用来检测数据类型，返回值是一个字符串（首字母都是小写的）比如”number”、”function”，对一个值使用typeof操作符可能返回下列某个字符串： “undefined”——如果这个值未定义； “boolean”——如果这个值是布尔值； “string”——如果这个值是字符串； “number”——如果这个值是数值； “object”——如果这个值是对象或null; “function”——如果这个值是函数。 注意：typeof null会返回”object”,因为null被认为是一个空的对象引用。 Undefined类型在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。包含undefined值的变量与尚未定义的变量是不一样的，看下面的例子：123var message;alert( message ); //undefined，message声明了但是没有赋值alert( age ); //报错，因为age未声明 然后，令人困惑的是：对未初始化的变量执行typeof操作符会返回undefined值，而对未声明的变量执行typeof操作符同样也会返回undefined值，看下面的例子：12alert(typeof message) //undefinedalert(typeof age) //undefined 未初始化的变量会自动被赋予undefined值 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。 实际上undefined值是派生自null值的，因此：alert( null == undefined ); // true 数据类型转换把一种数据类型转换成另一种数据类型。 1、转数字: Number(数据) 把数据转换成数字，返回这个数字（但是不会改变括号中数据的类型） parseInt(数据 ) 把数据转变成整数，舍去小数位取整数 parseFloat(数据 ) 把数据转变成小数（浮点数） parseInt(数据 )和 parseFloat(数据 ) 这两个方法会从左往右开始，除去空格，找到第一位非0数字，开始进行转换，直到转换到不是数字的那位为止，或者，转换出合适的值为止 注意： 如果数据的内容是纯粹的数字，才可以转成数字 否则会转换出NaN NaN： not a number 不是数字 数据类型是number NaN和任何东西都不相等，包括它自己 alert( NaN==NaN ) =&gt; false isNaN(数据): 判断数据是不是NaN 会把数据先使用Number进行转换，转换完之后再判断是不是NaN 如果数据是NaN那么返回true 如果数据不是NaN返回false 2、转字符串： String(数据) 把数据转换成字符串，返回这个字符串（但是不会改变括号中数据的类型） &quot;&quot;+ 3、转布尔值： Boolean(数据) 把数据转换成布尔值，返回这个布尔值（不会改变括号内数据的类型） !! 注意： 空字符串转换成false，其他非空的字符串都转换成true undefined,null,空字符串,0,NaN会转换成false,其余转变结果是true 隐式类型转换：不调用方法使数据的类型发生改变 +、-、*、/ 都可以进行隐试类型转换，在转换过程中没有调用方法，直接把两边都转换成数字 ，然后进行运算 + 还有字符串拼接功能，当两边有一个是字符串时就会把数字变成字符串，然后进行字符串拼接 ! 把数据转换成布尔值（比如： alert(!!2) //true） 显式类型转换： 使用一些方法 使数据的类型发生改变。 比如：Number()，parsent()，parseFloat()，String()，Boolean() 。。。 操作符算数运算符： + 加、- 减、* 乘、/ 除、% 取模（求余数）、++、-- + 除了有算数运算的功能还有字符串拼接的功能 只有当两边都是 数字的时候才会进行算数运算 只要有一边是字符串，那么就会把不是字符串的那边转换成字符串，然后进行拼接 ++ 和-- 可以写在运算数的前面也可以写在运算数的后面 比如： a++，写在运算数的后面，先使用a再进行++ ++a，写在运算数的前面，先++再使用a a--，写在运算数的后面，先使用a再进行-- --a，写在运算数的前面，先--再使用a 赋值运算符： =、+=、-=、*=、/=、%= a+=b 相当于 a = a + b（a放在前面） a = a + b可以简写成 a += b 但是 a = b + a不可以简写成 a += b -=、*=、/=、%=的特性和+=一样 关系运算符： &lt;、&gt;、&lt;=、&gt;=、==、!=、===、!== 注意：返回值都是一个布尔值 &lt;小于 如果左边的值小于右边那么返回true 否则返回false &gt;大于 如果左边的值大于右边那么返回true 否则返回false &lt;=小于等于 如果左边的值小于或者等于右边那么返回true 否则返回false &gt;=大于等于 如果左边的值大于或者等于右边那么返回true 否则返回false ==等于 如果左边的值等于右边那么返回true； 注意：只判断外在的值是否一样，不会判断左右两边值的数据类型 比如： 1 == &quot;1&quot; 返回 true var a=1,b=&quot;1&quot;; console.log(a==b) =&gt;true; != 不等于 如果左边的值不等于右边那么返回true； 注意：不会判断左右两边值的数据类型 比如： 1 != &quot;1&quot; 返回false ==和！= 先转换再比较 === 全等 如果左右两边的值相等，并且数据类型也相同，则返回true 如果值不相等，或者数据类型不相同，则返回false !== 全不等 如果左右两边的值不相等，或者数据类型不相同，则返回true 如果值相等，并且数据类型也相同，则返回false ===和！==仅比较不转换 比较两个操作符时的规则： 1. null和undefined是相等的 2. 要比较相等性之前，不能将null和undefined转换成其他任何值 3. NaN不等于任何值，包括它本身 4. 如果两个操作数都是对象，则比较它们是不是同一个对象 true==1 // true true==2 // false undefined==0 // false null==0 // false &quot;5&quot;==5 // true false == 0 //true null==undefined //true NaN != NaN //true 逻辑运算符： &amp;&amp; 与、|| 或、! 否 、三元运算符 &amp;&amp;与（并且） 如果左边为真，则返回右边， 如果左边为假，则返回左边。 ||或（或者） 如果左边为真，则返回左边， 如果左边为假，则返回右边。 !否 把后面的运算数转成布尔值然后取反 三元运算符 判断条件?语句1:语句2 如果判断条件成立，执行语句1， 判断条件不成立，执行语句2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于Hexo和Github搭建博客]]></title>
      <url>%2F2016%2F01%2F24%2Fhexo_github%2F</url>
      <content type="text"><![CDATA[Node Node.js — 类似一个操作系统 一个JS的运行环境 主要用于开发Web应用程序（回想登陆的例子） 很多的前端开发工具都是基于node这个平台 所用的工具就相当于一些软件 NVM （可选的） Node Version Manager(Node的版本管理工具) 因为node的版本比较多，很多时候我们可能依赖多个版本，并要求自由切换 使用 nvm use [对应的版本号] [平台架构（如果是32系统需要写32,64位不用管）] nvm install [arch] 安装 nvm uninstall 卸载 nvm list 查看已经安装版本 官网 https://github.com/coreybutler/nvm-windows NPM node package manager(node的包管理工具) npm管理包非常方便，我们只需要记住使用哪个包就可以了 使用 npm install xxx 安装一个包到项目本地，必须要联网 安装完成过后项目根目录下会多一个node_modules文件夹，所有的下载下来的包全部在里面 由于需要记录项目依赖哪些东西，所以需要一个配置文件“package.json”，可以通过npm init命令生成 以后安装包的时候将其–save –save就是将我们安装的包名字和包版本记录到配置文件中的dependencies节点中 –save-dev 项目依赖分两种，一个就是普通的项目依赖比如bootstrap，还用一种只是开发阶段需要用的，这种属于开发依赖比如gulp，开发依赖最终记录在devDependencies节点里面 npm uninstall xxx –save npm install xxx -g(全局安装包) 如果你安装的是一个工具，工具要在每一个地方都能用，这种情况下一般全局安装。 Bower Web sites are made of lots of things — frameworks, libraries, assets, and utilities. Bower manages all these things for you. Bower就是用来管理项目中所有的依赖，主要用于Web页面开发时使用的包管理，比如jquery，bootstrap 重复的轮子太多，抓住轮子与轮子之间的共性 Gulp FIS3 http://www.ydcss.com/archives/94 msi - microsoft installer 微软安装器 GIT什么是GIT 是一个源代码管理工具 在一个项目中，凡是由开发人员编写的都算是源代码 源代码有必要管理起来？ 让源代码可以被追溯，主要记录每次变更了什么，谁主导这次变化 人为的维护比较麻烦， GIT是Linux之父当年为了维护管理Linux的源代码写的一个工具 Git 之前 很多使用 svn vss tfs hs …… https://guides.github.com/ 安装GIT git命令行工具 基于git命令行的一个客户端软件（提供一个界面去管理源代码） GIT命令操作 初始化一个本地GIT仓储 12cd 当前项目目录git init // 初始化一个本地的仓库 就是在本地文件夹中添加了一个.git的文件夹用于记录所有的项目变更信息 查看本地仓储的变更状态 git status用于查看本地仓储的状态第一次查看，显示的是一坨没有被跟踪的文件 git status -s // -s 是输出简要的变更日志 添加本地暂存（托管）文件 git add可以将一个没有被跟踪的文件添加到跟踪列表 类似于node_modules这种性质的文件是不应该被跟踪 添加本地GIT忽略清单文件 在代码库文件夹的根目录添加一个.gitignore文件此文件用于说明忽略的文件有哪些 提交被托管的文件变化到本地仓储 git commit将本地的变化提交的本地的仓库文件夹归档一般在有了一个小单元的整体变化后再提交 对比差异 git diff可以用于对比当前状态和版本库中状态的变化 提交日志 git log可以查看提交日志 回归到指定版本 git reset –hard 为仓储添加远端（服务器端）地址 将本地仓储的提交记录推送到远端的master分支 拉取远端master分支的更新记录到本地 回归到指定版本 GITHUB基本使用 https://github.com/ GITHUB是一个GIT服务的提供商， 提出社交化编程 http://zoomzhao.github.io/code-guide/https://github.com/jobbole/awesome-javascript-cnhttps://github.com/jobbole/awesome-css-cn GIT分支]]></content>
    </entry>

    
  
  
</search>
